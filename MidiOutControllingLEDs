### cpx-basic-synth v1.4
### CircuitPython (on CPX) synth module using internal speaker
### Velocity sensitive monophonic synth
### with crude amplitude modulation (cc1) and choppy pitch bend

### Tested with CPX and CircuitPython and 4.0.0-beta.7

### Needs recent adafruit_midi module

### copy this file to CPX as code.py

### MIT License.

### Copyright (c) 2019 Kevin J. Walters

### Permission is hereby granted, free of charge, to any person obtaining a copy
### of this software and associated documentation files (the "Software"), to deal
### in the Software without restriction, including without limitation the rights
### to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
### copies of the Software, and to permit persons to whom the Software is
### furnished to do so, subject to the following conditions:

### The above copyright notice and this permission notice shall be included in all
### copies or substantial portions of the Software.

### THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
### IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
### FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
### AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
### LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
### OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
### SOFTWARE.

import array
import time
import math

import digitalio
import audioio
import audiocore
import board
import usb_midi
import neopixel

import adafruit_midi

from adafruit_midi.midi_message     import note_parser

from adafruit_midi.note_on          import NoteOn
from adafruit_midi.note_off         import NoteOff
from adafruit_midi.control_change   import ControlChange
from adafruit_midi.pitch_bend       import PitchBend


# 440Hz is the standard frequency for A4 (A above middle C)
# MIDI defines middle C as 60 and modulation wheel is cc 1 by convention
A4refhz = 440  # was const(440)
midi_note_C4 = note_parser("C4")
print("C4 is " + str(midi_note_C4))
midi_note_A4 = note_parser("A4")
print("A4 is " + str(midi_note_A4))
midi_cc_modwheel = 1  # was const(1)
twopi = 2 * math.pi

# set pins for each note

# 12 = C
# 11 = C#
# 10 = D

# so more like

# 60 = C = 12
# 61 = C# = 11

# add LED's
# ledG = digitalio.DigitalInOut(board.D1)
# ledG.direction = digitalio.Direction.OUTPUT
# n
# or do it like this

pinD13 = digitalio.DigitalInOut(board.D13)
pinD12 = digitalio.DigitalInOut(board.D12)
pinD11 = digitalio.DigitalInOut(board.D11)
pinD10 = digitalio.DigitalInOut(board.D10)
pinD9 = digitalio.DigitalInOut(board.D9)
pinD8 = digitalio.DigitalInOut(board.D8)
pinD7 = digitalio.DigitalInOut(board.D7)
pinD6 = digitalio.DigitalInOut(board.D6)
pinD5 = digitalio.DigitalInOut(board.D5)
pinD4 = digitalio.DigitalInOut(board.D4)
pinD3 = digitalio.DigitalInOut(board.D3)
pinD2 = digitalio.DigitalInOut(board.D2)

pinD13.direction = digitalio.Direction.OUTPUT
pinD12.direction = digitalio.Direction.OUTPUT
pinD11.direction = digitalio.Direction.OUTPUT
pinD10.direction = digitalio.Direction.OUTPUT
pinD9.direction = digitalio.Direction.OUTPUT
pinD8.direction = digitalio.Direction.OUTPUT
pinD7.direction = digitalio.Direction.OUTPUT
pinD6.direction = digitalio.Direction.OUTPUT
pinD5.direction = digitalio.Direction.OUTPUT
pinD4.direction = digitalio.Direction.OUTPUT
pinD3.direction = digitalio.Direction.OUTPUT
pinD2.direction = digitalio.Direction.OUTPUT


noteLEDs = [pinD13,
            pinD12,
            pinD11,
            pinD10,
            pinD9,
            pinD8,
            pinD7,
            pinD6,
            pinD5,
            pinD4,
            pinD3,
            pinD2]

# Brute forced

# brightness 1.0 saves memory by removing need for a second buffer
# 10 is number of NeoPixels on CPX
numpixels = 10  # was const(10)
pixels = neopixel.NeoPixel(board.NEOPIXEL, numpixels, brightness=1.0)

# Turn NeoPixel on to represent a note using RGB x 10
# to represent 30 notes - doesn't do anything with pitch bend
def noteLED(pix, pnote, pvel):
    



    
    note30 = (pnote - midi_note_C4) % (3 * numpixels)
    pos = note30 % numpixels
    r, g, b = pix[pos]
    if pvel == 0:
        brightness = 0
    else:
        # max brightness will be 32
        brightness = round(pvel / 127 * 30 + 2)
    # Pick R/G/B based on range within the 30 notes
    if note30 < 10:
        r = brightness
    elif note30 < 20:
        g = brightness
    else:
        b = brightness
    pix[pos] = (r, g, b)

# Calculate the note frequency from the midi_note with pitch bend
# of pb_st (float) semitones
# Returns float

midi_channel = 1
midi = adafruit_midi.MIDI(midi_in=usb_midi.ports[0],
                          in_channel=midi_channel-1)

# pitchbendrange in semitones - often 2 or 12
pb_midpoint = 8192
pitch_bend_multiplier = 2 / pb_midpoint
pitch_bend_value = pb_midpoint  # mid point - no bend

wave = []  # current or last wave played
last_note = None

# Amplitude modulation frequency in Hz
am_freq = 16
mod_wheel = 0

# Read any incoming MIDI messages (events) over USB
# looking for note on, note off, pitch bend change
# or control change for control 1 (modulation wheel)
# Apply crude amplitude modulation using speaker enable
while True:
    msg = midi.receive()
    if isinstance(msg, NoteOn) and msg.velocity != 0:
        last_note = msg.note
        print(str(msg.note) + ", " + str(msg.velocity))
        noteLED(pixels, msg.note, msg.velocity)

    elif (isinstance(msg, NoteOff) or isinstance(msg, NoteOn) and msg.velocity == 0):
        
        noteLED(pixels, msg.note, 0)  # turn off NeoPixel

    elif isinstance(msg, PitchBend):
        pitch_bend_value = msg.pitch_bend  # 0 to 16383
        if last_note is not None:
            pitch_bend = (pitch_bend_value - pb_midpoint) * pitch_bend_multiplier
            note_freq = note_frequency(last_note, pitch_bend)
            note_sample_rate = round(base_sample_rate * note_freq / A4refhz)
            if note_sample_rate > max_sample_rate:
                note_sample_rate = max_sample_rate
            wave[0].sample_rate = note_sample_rate  # must be integer
            dac.play(wave[0], loop=True)

    elif isinstance(msg, ControlChange):
        if msg.control == midi_cc_modwheel:
            mod_wheel = msg.value  # msg.value is 0 (none) to 127 (max)

    if mod_wheel > 0:
        t1 = time.monotonic() * am_freq
        # Calculate a form of duty_cycle for enabling speaker for crude
        # amplitude modulation. Empirically the divisor needs to greater
        # than 127 as can't hear much when speaker is off more than half
        # 220 works reasonably well
        new_speaker_on = (t1 - int(t1)) > (mod_wheel / 220)

